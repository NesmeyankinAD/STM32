#include "stm32f4xx.h"

void I2C_2_Init(void)
{
  RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOBEN;           //Включение тактирования порта B
  RCC -> APB1ENR |= RCC_APB1ENR_I2C2EN;            //Включение тактирования I2C2

  //Настройка пинов порта B
  GPIOB -> MODER |= GPIO_MODER_MODE10_1;           //10 - Альтернативная функция: PB10 - SCL
  GPIOB -> MODER |= GPIO_MODER_MODE11_1;           //10 - Альтернативная функция: PB11 - SDA

  GPIOB -> AFR[1] |= (4 << GPIO_AFRH_AFSEL10_Pos); // Задание альт. функции №4 - I2C2 для пина 10
  GPIOB -> AFR[1] |= (4 << GPIO_AFRH_AFSEL11_Pos); // Задание альт. функции №4 - I2C2 для пина 11

  GPIOB -> PUPDR &= ~(GPIO_PUPDR_PUPD10);          //Явное отключение подтяжек PB10
  GPIOB -> PUPDR &= ~(GPIO_PUPDR_PUPD11);          //Явное отключение подтяжек PB11

  GPIOB -> OTYPER |= GPIO_OTYPER_OT10;             //Тип выхода - открытый коллектор,
  GPIOB -> OTYPER |= GPIO_OTYPER_OT11;             //необходимо для того, чтобы подчинённое устройство 
                                                   //могло опустить шину в ноль - отвечать битом ACK

  //Настройка модуля I2C2
  /*Подробности настройки
    По умолчанию I2C Работает в подчинённом режиме (Slave).
    Интерфейс автоматически переключается с режима Slave на Master после того, как он сгенерирует START-условие.
    Из Master в Slave происходит переключение в случае арбитражного проигрыша или при генерации STOP-условия на шине,
  что обеспечивает возможность работы с несколькими ведущими устройствами.

    Режим работы                    = Master
    Скорость чтения/записи          = 100 Кбит/сек
    Адресация на шине I2C           = 7-битная
    DMA                             = не используется, отключено (по умолчанию отключено)
    Прерывания                      = не используются, отключены (по умолчанию отключены)
    Адрес микросхемы EEPROM на шине = 0xA0 (0b1010 0000). Используются старшие 7 бит
  */

  I2C2 -> CR2 |= (42 << I2C_CR2_FREQ_Pos);         //Частота тактирования I2C2 = 42 МГц, 
                                                   //максимум шины APB1

  /* Вычисление значения CCR:
     Частота приёма/передачи I2C = 100 кГц - Standard mode

     Thigh = CCR * T_plck1
     Tlow = CCR * T_pclk1
     Tsm = 1/(I2C_freq) = 1/100000 = Thigh + Tlow;
     1/100000 = 2 * CCR * T_pclk1
     CCR = 1 / (2*100000*T_pclk1)
     T_pclk1 = 1 / Freq_APB1;
     Freq_APB1 = 42 MHz
     T_Pclk1 = 1 / 42000000
     CCR = 42000000 / (2*100000) = 210;
  */

  I2C2 -> CCR |= (210 << I2C_CCR_CCR_Pos);         //Скорость приёма/передачи 100 КБит/с
  I2C2 -> CCR &= ~(I2C_CCR_FS);                    //Явное указание режима работы I2C, сброс бита Fast Mode

  I2C2 -> TRISE |= ((42+1) << I2C_CR2_FREQ_Pos);   //Фронт сигналов (Частота тактирования I2C + 1)

  I2C2 -> OAR1 &= ~(I2C_OAR1_ADDMODE);             //Используем 7-битную адрессацию
  
  I2C2 -> CR1 |= I2C_CR1_PE;                       //Включение I2C2 в работу
  I2C2 -> CR1 |= I2C_CR1_ACK;                      //Разрешение на генерацию битов Acknowlege
                                                   //(только после бита PE !)
}